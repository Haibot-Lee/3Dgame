<!DOCTYPE html>
<html>

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

    <title>The Sun Creator</title>
    <style>
        html,
        body {
            width: 100%;
            height: 100%;
        }

        body {
            background-color: #ffffff;
            margin: 0;
            overflow: hidden;
            font-family: arial;
        }

        #blocker {

            position: absolute;

            width: 100%;
            height: 100%;

            background-color: rgba(0, 0, 0, 0.5);

        }

        #instructions {

            width: 100%;
            height: 100%;

            display: -webkit-box;
            display: -moz-box;
            display: box;

            -webkit-box-orient: horizontal;
            -moz-box-orient: horizontal;
            box-orient: horizontal;

            -webkit-box-pack: center;
            -moz-box-pack: center;
            box-pack: center;

            -webkit-box-align: center;
            -moz-box-align: center;
            box-align: center;

            color: #ffffff;
            text-align: center;

            cursor: pointer;

        }
    </style>
</head>

<body data-new-gr-c-s-check-loaded="14.1001.0" data-gr-ext-installed="">
    <!-- <script src="js/three.js"></script> -->
    <script src="js/three_inClass.js"></script>
    <script src="js/cannon.js"></script>
    <script src="js/PointerLockControls.js"></script>

    <div id="blocker">

        <div id="instructions">
            <span style="font-size:40px">Click to play</span>
            <br>
            (MOUSE = Look, CLICK = Shoot)
        </div>

    </div>

    <script>

        var sphereShape, sphereBody, world, physicsMaterial, walls = [], balls = [], ballMeshes = [], boxes = [], boxMeshes = [];

        var camera, scene, renderer;
        var geometry, material, mesh;
        var controls, time = Date.now();

        var planetSizes = new Array();
        var cnt = 0;

        var blocker = document.getElementById('blocker');
        var instructions = document.getElementById('instructions');

        var materials = new Array();
        var texLoader = new THREE.TextureLoader();

        var unit = 5;

        //10: Pluto
        texture = texLoader.load("textures/pluto.jpg");
        materials[0] = new THREE.MeshBasicMaterial({
            map: texture,
        });
        planetSizes[0] = 0.187 * unit*2;

        //4: Moon
        texture = texLoader.load("textures/moon.jpg");
        materials[1] = new THREE.MeshBasicMaterial({
            map: texture,
        });
        planetSizes[1] = 0.273 * unit*2;

        //1: Mercury
        texture = texLoader.load("textures/mercury.jpeg");
        materials[2] = new THREE.MeshBasicMaterial({
            map: texture,
        });
        planetSizes[2] = 0.383 * unit*2;

        //5: Mars
        texture = texLoader.load("textures/mars.jpeg");
        materials[3] = new THREE.MeshBasicMaterial({
            map: texture,
        });
        planetSizes[3] = 0.532 * unit *1.5;
        //2: Venus
        texture = texLoader.load("textures/venus.jpeg");
        materials[4] = new THREE.MeshBasicMaterial({
            map: texture,
        });
        planetSizes[4] = 0.95 * unit;
        //3: Earth
        texture = texLoader.load("textures/earth.jpg");
        materials[5] = new THREE.MeshBasicMaterial({
            map: texture,
        });
        planetSizes[5] = unit;

        //9: Neptune
        texture = texLoader.load("textures/neptune.jpeg");
        materials[6] = new THREE.MeshBasicMaterial({
            map: texture,
        });
        planetSizes[6] = 3.87 * unit / 2;
        //8: Uranus
        texture = texLoader.load("textures/uranus.jpeg");
        materials[7] = new THREE.MeshBasicMaterial({
            map: texture,
        });
        planetSizes[7] = 3.98 * unit / 2;
        //7: Saturn
        texture = texLoader.load("textures/saturn.jpeg");
        materials[8] = new THREE.MeshBasicMaterial({
            map: texture,
        });
        planetSizes[8] = 9.14 * unit / 7;
        //6: Jupiter
        texture = texLoader.load("textures/jupiter.jpeg");
        materials[9] = new THREE.MeshBasicMaterial({
            map: texture,
        });
        planetSizes[9] = 10.97 * unit / 8;
        //0: Sun
        var texture = texLoader.load("textures/sun.jpg");
        materials[10] = new THREE.MeshBasicMaterial({
            map: texture,
        });
        planetSizes[10] = 190.25 * unit/80;
        

        var havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;

        if (havePointerLock) {

            var element = document.body;

            var pointerlockchange = function (event) {

                if (document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element) {

                    controls.enabled = true;

                    blocker.style.display = 'none';

                } else {

                    controls.enabled = false;

                    blocker.style.display = '-webkit-box';
                    blocker.style.display = '-moz-box';
                    blocker.style.display = 'box';

                    instructions.style.display = '';

                }

            }

            var pointerlockerror = function (event) {
                instructions.style.display = '';
            }

            // Hook pointer lock state change events
            document.addEventListener('pointerlockchange', pointerlockchange, false);
            document.addEventListener('mozpointerlockchange', pointerlockchange, false);
            document.addEventListener('webkitpointerlockchange', pointerlockchange, false);

            document.addEventListener('pointerlockerror', pointerlockerror, false);
            document.addEventListener('mozpointerlockerror', pointerlockerror, false);
            document.addEventListener('webkitpointerlockerror', pointerlockerror, false);

            instructions.addEventListener('click', function (event) {
                instructions.style.display = 'none';

                // Ask the browser to lock the pointer
                element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;

                if (/Firefox/i.test(navigator.userAgent)) {

                    var fullscreenchange = function (event) {

                        if (document.fullscreenElement === element || document.mozFullscreenElement === element || document.mozFullScreenElement === element) {

                            document.removeEventListener('fullscreenchange', fullscreenchange);
                            document.removeEventListener('mozfullscreenchange', fullscreenchange);

                            element.requestPointerLock();
                        }

                    }

                    document.addEventListener('fullscreenchange', fullscreenchange, false);
                    document.addEventListener('mozfullscreenchange', fullscreenchange, false);

                    element.requestFullscreen = element.requestFullscreen || element.mozRequestFullscreen || element.mozRequestFullScreen || element.webkitRequestFullscreen;

                    element.requestFullscreen();

                } else {

                    element.requestPointerLock();

                }

            }, false);

        } else {

            instructions.innerHTML = 'Your browser doesn\'t seem to support Pointer Lock API';

        }

        initCannon();
        init();
        animate();

        function initCannon() {
            // Setup our world
            world = new CANNON.World();
            world.quatNormalizeSkip = 0;
            world.quatNormalizeFast = false;

            var solver = new CANNON.GSSolver();

            world.defaultContactMaterial.contactEquationStiffness = 1e9;
            world.defaultContactMaterial.contactEquationRelaxation = 4;

            solver.iterations = 7;
            solver.tolerance = 0.1;
            var split = true;
            if (split)
                world.solver = new CANNON.SplitSolver(solver);
            else
                world.solver = solver;

            world.gravity.set(0, -20, 0);
            world.broadphase = new CANNON.NaiveBroadphase();

            // Create a slippery material (friction coefficient = 0.0)
            physicsMaterial = new CANNON.Material("slipperyMaterial");
            var physicsContactMaterial = new CANNON.ContactMaterial(physicsMaterial,
                physicsMaterial,
                0.0, // friction coefficient
                0.3  // restitution
            );
            // We must add the contact materials to the world
            world.addContactMaterial(physicsContactMaterial);

            // Create a sphere
            // change mass to hover the camera
            var mass = 0, radius = 1.3;
            sphereShape = new CANNON.Sphere(radius);
            sphereBody = new CANNON.Body({ mass: mass });
            sphereBody.addShape(sphereShape);
            sphereBody.position.set(0, 60, 0);
            sphereBody.linearDamping = 0.9;
            world.add(sphereBody);

            // Create a plane
            var groundShape = new CANNON.Plane();
            var groundBody = new CANNON.Body({ mass: 0 });
            groundBody.addShape(groundShape);
            groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
            world.add(groundBody);
        }

        function init() {

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x000000, 0, 500);

            var ambient = new THREE.AmbientLight(0x111111);
            scene.add(ambient);

            light = new THREE.SpotLight(0xffffff);
            light.position.set(0, 80, 0);
            light.target.position.set(0, 0, 0);
            if (true) {
                light.castShadow = true;

                light.shadowCameraNear = 20;
                light.shadowCameraFar = 50;//camera.far;
                light.shadowCameraFov = 40;

                light.shadowMapBias = 0.1;
                light.shadowMapDarkness = 0.7;
                light.shadowMapWidth = 2 * 512;
                light.shadowMapHeight = 2 * 512;

                light.shadowCameraVisible = true;
            }
            scene.add(light);
            controls = new PointerLockControls(camera, sphereBody);
            scene.add(controls.getObject());

            // floor
            geometry = new THREE.PlaneGeometry(300, 300, 50, 50);
            geometry.applyMatrix(new THREE.Matrix4().makeRotationX(- Math.PI / 2));


            var texLoader = new THREE.TextureLoader();
            //var texture = texLoader.load("textures/8k_milkyWay.jpg");
            var texture = texLoader.load("textures/star.jpg");

            material = new THREE.MeshBasicMaterial({
                map: texture,
            });

            //material = new THREE.MeshLambertMaterial({ color: 0xdddddd });

            mesh = new THREE.Mesh(geometry, material);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);

            renderer = new THREE.WebGLRenderer();
            renderer.shadowMapEnabled = true;
            renderer.shadowMapSoft = true;
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(scene.fog.color, 1);

            document.body.appendChild(renderer.domElement);

            window.addEventListener('resize', onWindowResize, false);

            // Add boxes
            var boxSize = 20;
            var halfExtents = new CANNON.Vec3(boxSize, boxSize, boxSize);
            var boxShape = new CANNON.Box(halfExtents);
            var boxGeometry = new THREE.BoxGeometry(halfExtents.x * 2, halfExtents.y * 2, halfExtents.z * 2);


            // TODO: use boxes to make a boundary

            var distance = 40;
            var height = 20;
            //for (var i = 0; i < 3; i++) {
            var x = distance;
            var y = height;
            var z = 0;

            var boxBody = new CANNON.Body({ mass: 10000 });

            //var texLoader = new THREE.TextureLoader();
            //var texture = texLoader.load("textures/sun.jpg");
            material = new THREE.MeshBasicMaterial({
                map: texture,
            });

            // for testing
            //var material = new THREE.MeshLambertMaterial({ color: 0x39C5BB });


            boxBody.addShape(boxShape);
            var boxMesh = new THREE.Mesh(boxGeometry, material);
            world.add(boxBody);
            scene.add(boxMesh);
            boxBody.position.set(x, y, z);
            boxMesh.position.set(x, y, z);
            boxMesh.castShadow = true;
            boxMesh.receiveShadow = true;
            boxes.push(boxBody);
            boxMeshes.push(boxMesh);


            var x = 0;
            var y = height;
            var z = distance;

            var boxBody = new CANNON.Body({ mass: 10000 });
            boxBody.addShape(boxShape);
            var boxMesh = new THREE.Mesh(boxGeometry, material);
            world.add(boxBody);
            scene.add(boxMesh);
            boxBody.position.set(x, y, z);
            boxMesh.position.set(x, y, z);
            boxMesh.castShadow = true;
            boxMesh.receiveShadow = true;
            boxes.push(boxBody);
            boxMeshes.push(boxMesh);


            var x = distance;
            var y = height;
            var z = distance;

            var boxBody = new CANNON.Body({ mass: 10000 });
            boxBody.addShape(boxShape);
            var boxMesh = new THREE.Mesh(boxGeometry, material);
            world.add(boxBody);
            scene.add(boxMesh);
            boxBody.position.set(x, y, z);
            boxMesh.position.set(x, y, z);
            boxMesh.castShadow = true;
            boxMesh.receiveShadow = true;
            boxes.push(boxBody);
            boxMeshes.push(boxMesh);


            var x = -distance;
            var y = height;
            var z = 0;

            var boxBody = new CANNON.Body({ mass: 10000 });
            boxBody.addShape(boxShape);
            var boxMesh = new THREE.Mesh(boxGeometry, material);
            world.add(boxBody);
            scene.add(boxMesh);
            boxBody.position.set(x, y, z);
            boxMesh.position.set(x, y, z);
            boxMesh.castShadow = true;
            boxMesh.receiveShadow = true;
            boxes.push(boxBody);
            boxMeshes.push(boxMesh);


            var x = distance;
            var y = height;
            var z = -distance;

            var boxBody = new CANNON.Body({ mass: 10000 });
            boxBody.addShape(boxShape);
            var boxMesh = new THREE.Mesh(boxGeometry, material);
            world.add(boxBody);
            scene.add(boxMesh);
            boxBody.position.set(x, y, z);
            boxMesh.position.set(x, y, z);
            boxMesh.castShadow = true;
            boxMesh.receiveShadow = true;
            boxes.push(boxBody);
            boxMeshes.push(boxMesh);

            var x = -distance;
            var y = height;
            var z = distance;

            var boxBody = new CANNON.Body({ mass: 10000 });
            boxBody.addShape(boxShape);
            var boxMesh = new THREE.Mesh(boxGeometry, material);
            world.add(boxBody);
            scene.add(boxMesh);
            boxBody.position.set(x, y, z);
            boxMesh.position.set(x, y, z);
            boxMesh.castShadow = true;
            boxMesh.receiveShadow = true;
            boxes.push(boxBody);
            boxMeshes.push(boxMesh);

            var x = -distance;
            var y = height;
            var z = -distance;

            var boxBody = new CANNON.Body({ mass: 10000 });
            boxBody.addShape(boxShape);
            var boxMesh = new THREE.Mesh(boxGeometry, material);
            world.add(boxBody);
            scene.add(boxMesh);
            boxBody.position.set(x, y, z);
            boxMesh.position.set(x, y, z);
            boxMesh.castShadow = true;
            boxMesh.receiveShadow = true;
            boxes.push(boxBody);
            boxMeshes.push(boxMesh);


            var x = 0;
            var y = height;
            var z = -distance;

            var boxBody = new CANNON.Body({ mass: 10000 });
            boxBody.addShape(boxShape);
            var boxMesh = new THREE.Mesh(boxGeometry, material);
            world.add(boxBody);
            scene.add(boxMesh);
            boxBody.position.set(x, y, z);
            boxMesh.position.set(x, y, z);
            boxMesh.castShadow = true;
            boxMesh.receiveShadow = true;
            boxes.push(boxBody);
            boxMeshes.push(boxMesh);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        var dt = 1 / 60;
        function animate() {
            requestAnimationFrame(animate);
            if (controls.enabled) {
                world.step(dt);

                // Update ball positions
                for (var i = 0; i < balls.length; i++) {
                    ballMeshes[i].position.copy(balls[i].position);
                    ballMeshes[i].quaternion.copy(balls[i].quaternion);
                }

                // Update box positions
                for (var i = 0; i < boxes.length; i++) {
                    boxMeshes[i].position.copy(boxes[i].position);
                    boxMeshes[i].quaternion.copy(boxes[i].quaternion);
                }
            }

            controls.update(Date.now() - time);
            renderer.render(scene, camera);
            time = Date.now();
        }

        function checkMerge() {
            for (var j = 0; j < balls.length; j++) {
                for (var i = 0; i < balls.length; i++) {
                    //if () {

                    //}
                    var x = sphereBody.position.x;
                    var y = sphereBody.position.y;
                    var z = sphereBody.position.z;
                    var ballBody = new CANNON.Body({ mass: 1 });

                    var length = planetSizes.length;
                    
                    var ballShape = new CANNON.Sphere(planetSizes[cnt % length]);

                    ballBody.addShape(ballShape);
                    var ballGeometry = new THREE.SphereGeometry(ballShape.radius, 32, 32);
                    var ballMesh = new THREE.Mesh(ballGeometry, materials[cnt % length]);
                    world.add(ballBody);
                    scene.add(ballMesh);
                    
                    ballMesh.castShadow = true;
                    ballMesh.receiveShadow = true;
                    balls.push(ballBody);
                    ballMeshes.push(ballMesh);

                    ballBody.velocity.set(0,
                        0,
                        0);

                    ballBody.position.set(x, y, z);
                    ballMesh.position.set(x, y, z);
                }
            }
        }

        var shootDirection = new THREE.Vector3();
        var shootVelo = 15;
        var projector = new THREE.Projector();
        function getShootDir(targetVec) {
            var vector = targetVec;
            targetVec.set(0, 0, 1);
            projector.unprojectVector(vector, camera);
            var ray = new THREE.Ray(sphereBody.position, vector.sub(sphereBody.position).normalize());
            targetVec.copy(ray.direction);
        }

        window.addEventListener("click", function (e) {
            if (controls.enabled == true) {
                var x = sphereBody.position.x;
                var y = sphereBody.position.y;
                var z = sphereBody.position.z;
                var ballBody = new CANNON.Body({ mass: 1 });

                //var ballShape = new CANNON.Sphere(2 + 0.2 * (cnt % 10));
                var length = planetSizes.length;
                //console.log(cnt);
                //console.log(length - (cnt % length));
                //var length = planetSizes.length;

                var ballShape = new CANNON.Sphere(planetSizes[cnt % length]);

                ballBody.addShape(ballShape);
                var ballGeometry = new THREE.SphereGeometry(ballShape.radius, 32, 32);
                var ballMesh = new THREE.Mesh(ballGeometry, materials[cnt % length]);
                world.add(ballBody);
                scene.add(ballMesh);
                
                ballMesh.castShadow = true;
                ballMesh.receiveShadow = true;
                balls.push(ballBody);
                ballMeshes.push(ballMesh);
                getShootDir(shootDirection);
                ballBody.velocity.set(shootDirection.x * shootVelo,
                    shootDirection.y * shootVelo,
                    shootDirection.z * shootVelo);

                // Move the ball outside the player sphere
                x += shootDirection.x * (sphereShape.radius * 1.02 + ballShape.radius);
                y += shootDirection.y * (sphereShape.radius * 1.02 + ballShape.radius);
                z += shootDirection.z * (sphereShape.radius * 1.02 + ballShape.radius);
                ballBody.position.set(x, y, z);
                ballMesh.position.set(x, y, z);

                var collided=false;

                ballBody.addEventListener("collide", function(e){ 
                    console.log("collision")
                    for(var i =0 ;i<balls.length;i++){
                        if(Math.round(ballMeshes[i].position.distanceTo(ballMesh.position)*0.5)==Math.round(ballShape.radius)){
                            console.log("same");
                            console.log("Master: " + i + "; Slave:" + cnt % length);
                            if(i == cnt%length) {
                                console.log("Merge");

                                /*
                                world.remove(balls[i]);
                                scene.remove(ballMeshes[i]);
                                
                                balls.pop(balls[i]);
                                ballMeshes.pop(ballMeshes[i]);
                                */

                            }
                        }
                    }
                } );
            }
            //cnt++;
            //cnt = Math.floor(Math.random() * 6);
            cnt == 1;
        });


    </script><canvas width="1848" height="1428" style="width: 924px; height: 714px;"></canvas>


</body>

</html>