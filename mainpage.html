<!DOCTYPE html>
<html>

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

    <title>The Sun Creator</title>
    <style>
        html,
        body {
            width: 100%;
            height: 100%;
        }

        body {
            background-color: #ffffff;
            margin: 0;
            overflow: hidden;
            font-family: arial;
        }

        #blocker {

            position: absolute;

            width: 100%;
            height: 100%;

            background-color: rgba(0, 0, 0, 0.5);

        }

        #instructions {

            width: 100%;
            height: 100%;

            display: -webkit-box;
            display: -moz-box;
            display: box;

            -webkit-box-orient: horizontal;
            -moz-box-orient: horizontal;
            box-orient: horizontal;

            -webkit-box-pack: center;
            -moz-box-pack: center;
            box-pack: center;

            -webkit-box-align: center;
            -moz-box-align: center;
            box-align: center;

            color: #ffffff;
            text-align: center;

            cursor: pointer;

        }

        #display {
            color: #ffffff;
            position: absolute;
            width: 100%;
            height: 100%;
        }
    </style>
</head>

<body data-new-gr-c-s-check-loaded="14.1001.0" data-gr-ext-installed="">
    <!-- <script src="js/three.js"></script> -->
    <script src="js/three_inClass.js"></script>
    <script src="js/cannon.js"></script>
    <script src="js/PointerLockControls.js"></script>

    <div id='display'>
        <span id='score' style="font-size:30px">Score: </span>
        <br>
    </div>

    <div id="blocker">
        <div id="instructions">
            <span style="font-size:40px">Click to play</span>
            <br>
            (MOUSE = Look, CLICK = Shoot)
        </div>
    </div>

    <script>

        var sphereShape, sphereBody, world, physicsMaterial, walls = [], balls = [], ballMeshes = [], boxes = [], boxMeshes = [];

        var camera, scene, renderer;
        var geometry, material, mesh;
        var controls, time = Date.now();

        var planetSizes = new Array();
        var cnt = -1;
        var nextPlanet;

        var blocker = document.getElementById('blocker');
        var instructions = document.getElementById('instructions');

        var materials = new Array();
        var texLoader = new THREE.TextureLoader();

        var unit = 5;

        //10: Pluto
        texture = texLoader.load("textures/pluto.jpg");
        materials[0] = new THREE.MeshBasicMaterial({
            map: texture,
        });
        planetSizes[0] = 0.187 * unit * 2;

        //4: Moon
        texture = texLoader.load("textures/moon.jpg");
        materials[1] = new THREE.MeshBasicMaterial({
            map: texture,
        });
        planetSizes[1] = 0.273 * unit * 2;

        //1: Mercury
        texture = texLoader.load("textures/mercury.jpeg");
        materials[2] = new THREE.MeshBasicMaterial({
            map: texture,
        });
        planetSizes[2] = 0.383 * unit * 2;

        //5: Mars
        texture = texLoader.load("textures/mars.jpeg");
        materials[3] = new THREE.MeshBasicMaterial({
            map: texture,
        });
        planetSizes[3] = 0.532 * unit * 1.5;
        //2: Venus
        texture = texLoader.load("textures/venus.jpeg");
        materials[4] = new THREE.MeshBasicMaterial({
            map: texture,
        });
        planetSizes[4] = 0.95 * unit;
        //3: Earth
        texture = texLoader.load("textures/earth.jpg");
        materials[5] = new THREE.MeshBasicMaterial({
            map: texture,
        });
        planetSizes[5] = unit;

        //9: Neptune
        texture = texLoader.load("textures/neptune.jpeg");
        materials[6] = new THREE.MeshBasicMaterial({
            map: texture,
        });
        planetSizes[6] = 3.87 * unit / 2;
        //8: Uranus
        texture = texLoader.load("textures/uranus.jpeg");
        materials[7] = new THREE.MeshBasicMaterial({
            map: texture,
        });
        planetSizes[7] = 3.98 * unit / 2;
        //7: Saturn
        texture = texLoader.load("textures/saturn.jpeg");
        materials[8] = new THREE.MeshBasicMaterial({
            map: texture,
        });
        planetSizes[8] = 9.14 * unit / 7;
        //6: Jupiter
        texture = texLoader.load("textures/jupiter.jpeg");
        materials[9] = new THREE.MeshBasicMaterial({
            map: texture,
        });
        planetSizes[9] = 10.97 * unit / 8;
        //0: Sun
        var texture = texLoader.load("textures/sun.jpg");
        materials[10] = new THREE.MeshBasicMaterial({
            map: texture,
        });
        planetSizes[10] = 190.25 * unit / 80;


        var havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;

        if (havePointerLock) {

            var element = document.body;

            var pointerlockchange = function (event) {

                if (document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element) {

                    controls.enabled = true;

                    blocker.style.display = 'none';

                } else {

                    controls.enabled = false;

                    blocker.style.display = '';
                    instructions.style.display = '';

                }

            }

            var pointerlockerror = function (event) {
                instructions.style.display = '';
            }

            // Hook pointer lock state change events
            document.addEventListener('pointerlockchange', pointerlockchange, false);
            document.addEventListener('mozpointerlockchange', pointerlockchange, false);
            document.addEventListener('webkitpointerlockchange', pointerlockchange, false);

            document.addEventListener('pointerlockerror', pointerlockerror, false);
            document.addEventListener('mozpointerlockerror', pointerlockerror, false);
            document.addEventListener('webkitpointerlockerror', pointerlockerror, false);

            instructions.addEventListener('click', function (event) {
                instructions.style.display = 'none';

                // Ask the browser to lock the pointer
                element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;

                if (/Firefox/i.test(navigator.userAgent)) {

                    var fullscreenchange = function (event) {

                        if (document.fullscreenElement === element || document.mozFullscreenElement === element || document.mozFullScreenElement === element) {

                            document.removeEventListener('fullscreenchange', fullscreenchange);
                            document.removeEventListener('mozfullscreenchange', fullscreenchange);

                            element.requestPointerLock();
                        }

                    }

                    document.addEventListener('fullscreenchange', fullscreenchange, false);
                    document.addEventListener('mozfullscreenchange', fullscreenchange, false);

                    element.requestFullscreen = element.requestFullscreen || element.mozRequestFullscreen || element.mozRequestFullScreen || element.webkitRequestFullscreen;

                    element.requestFullscreen();

                } else {

                    element.requestPointerLock();

                }

            }, false);

        } else {

            instructions.innerHTML = 'Your browser doesn\'t seem to support Pointer Lock API';

        }

        initCannon();
        init();
        animate();

        function initCannon() {
            // Setup our world
            world = new CANNON.World();
            world.quatNormalizeSkip = 0;
            world.quatNormalizeFast = false;

            var solver = new CANNON.GSSolver();

            world.defaultContactMaterial.contactEquationStiffness = 1e9;
            world.defaultContactMaterial.contactEquationRelaxation = 4;

            solver.iterations = 7;
            solver.tolerance = 0.1;
            var split = true;
            if (split)
                world.solver = new CANNON.SplitSolver(solver);
            else
                world.solver = solver;

            world.gravity.set(0, -20, 0);
            world.broadphase = new CANNON.NaiveBroadphase();

            // Create a slippery material (friction coefficient = 0.0)
            physicsMaterial = new CANNON.Material("slipperyMaterial");
            var physicsContactMaterial = new CANNON.ContactMaterial(physicsMaterial,
                physicsMaterial,
                0.0, // friction coefficient
                0.3  // restitution
            );
            // We must add the contact materials to the world
            world.addContactMaterial(physicsContactMaterial);

            // Create a sphere
            // change mass to hover the camera
            var mass = 0, radius = 1.3;
            sphereShape = new CANNON.Sphere(radius);
            sphereBody = new CANNON.Body({ mass: mass });
            sphereBody.addShape(sphereShape);
            sphereBody.position.set(0, 60, 0);
            sphereBody.linearDamping = 0.9;
            world.add(sphereBody);

            // Create a plane
            var groundShape = new CANNON.Plane();
            var groundBody = new CANNON.Body({ mass: 0 });
            groundBody.addShape(groundShape);
            groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
            world.add(groundBody);
        }

        function init() {

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x000000, 0, 500);

            var ambient = new THREE.AmbientLight(0x111111);
            scene.add(ambient);

            light = new THREE.SpotLight(0xffffff);
            light.position.set(0, 80, 0);
            light.target.position.set(0, 0, 0);
            if (true) {
                light.castShadow = true;

                light.shadowCameraNear = 20;
                light.shadowCameraFar = 50;//camera.far;
                light.shadowCameraFov = 40;

                light.shadowMapBias = 0.1;
                light.shadowMapDarkness = 0.7;
                light.shadowMapWidth = 2 * 512;
                light.shadowMapHeight = 2 * 512;

                light.shadowCameraVisible = true;
            }
            scene.add(light);
            controls = new PointerLockControls(camera, sphereBody);
            scene.add(controls.getObject());

            //next planet
            nextPlanet = new THREE.Mesh(new THREE.SphereGeometry(planetSizes[cnt % planetSizes.length], 32, 32), materials[cnt % planetSizes.length]);
            scene.add(nextPlanet);
            nextPlanet.position.set(0, 50, -20);

            // floor
            geometry = new THREE.PlaneGeometry(300, 300, 50, 50);
            geometry.applyMatrix(new THREE.Matrix4().makeRotationX(- Math.PI / 2));


            var texLoader = new THREE.TextureLoader();
            //var texture = texLoader.load("textures/8k_milkyWay.jpg");
            var texture = texLoader.load("textures/star.jpg");

            material = new THREE.MeshBasicMaterial({
                map: texture,
            });

            //material = new THREE.MeshLambertMaterial({ color: 0xdddddd });

            mesh = new THREE.Mesh(geometry, material);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);

            renderer = new THREE.WebGLRenderer();
            renderer.shadowMapEnabled = true;
            renderer.shadowMapSoft = true;
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(scene.fog.color, 1);

            document.body.appendChild(renderer.domElement);

            window.addEventListener('resize', onWindowResize, false);

            // Add boxes
            var boxSize = 20;
            var halfExtents = new CANNON.Vec3(boxSize, boxSize, boxSize);
            var boxShape = new CANNON.Box(halfExtents);
            var boxGeometry = new THREE.BoxGeometry(halfExtents.x * 2, halfExtents.y * 2, halfExtents.z * 2);


            // TODO: use boxes to make a boundary

            var distance = 40;
            var height = 20;
            //for (var i = 0; i < 3; i++) {
            var x = distance;
            var y = height;
            var z = 0;

            var boxBody = new CANNON.Body({ mass: 10000 });

            //var texLoader = new THREE.TextureLoader();
            //var texture = texLoader.load("textures/sun.jpg");
            material = new THREE.MeshBasicMaterial({
                map: texture,
            });

            // for testing
            //var material = new THREE.MeshLambertMaterial({ color: 0x39C5BB });


            boxBody.addShape(boxShape);
            var boxMesh = new THREE.Mesh(boxGeometry, material);
            world.add(boxBody);
            scene.add(boxMesh);
            boxBody.position.set(x, y, z);
            boxMesh.position.set(x, y, z);
            boxMesh.castShadow = true;
            boxMesh.receiveShadow = true;
            boxes.push(boxBody);
            boxMeshes.push(boxMesh);


            var x = 0;
            var y = height;
            var z = distance;

            var boxBody = new CANNON.Body({ mass: 10000 });
            boxBody.addShape(boxShape);
            var boxMesh = new THREE.Mesh(boxGeometry, material);
            world.add(boxBody);
            scene.add(boxMesh);
            boxBody.position.set(x, y, z);
            boxMesh.position.set(x, y, z);
            boxMesh.castShadow = true;
            boxMesh.receiveShadow = true;
            boxes.push(boxBody);
            boxMeshes.push(boxMesh);


            var x = distance;
            var y = height;
            var z = distance;

            var boxBody = new CANNON.Body({ mass: 10000 });
            boxBody.addShape(boxShape);
            var boxMesh = new THREE.Mesh(boxGeometry, material);
            world.add(boxBody);
            scene.add(boxMesh);
            boxBody.position.set(x, y, z);
            boxMesh.position.set(x, y, z);
            boxMesh.castShadow = true;
            boxMesh.receiveShadow = true;
            boxes.push(boxBody);
            boxMeshes.push(boxMesh);


            var x = -distance;
            var y = height;
            var z = 0;

            var boxBody = new CANNON.Body({ mass: 10000 });
            boxBody.addShape(boxShape);
            var boxMesh = new THREE.Mesh(boxGeometry, material);
            world.add(boxBody);
            scene.add(boxMesh);
            boxBody.position.set(x, y, z);
            boxMesh.position.set(x, y, z);
            boxMesh.castShadow = true;
            boxMesh.receiveShadow = true;
            boxes.push(boxBody);
            boxMeshes.push(boxMesh);


            var x = distance;
            var y = height;
            var z = -distance;

            var boxBody = new CANNON.Body({ mass: 10000 });
            boxBody.addShape(boxShape);
            var boxMesh = new THREE.Mesh(boxGeometry, material);
            world.add(boxBody);
            scene.add(boxMesh);
            boxBody.position.set(x, y, z);
            boxMesh.position.set(x, y, z);
            boxMesh.castShadow = true;
            boxMesh.receiveShadow = true;
            boxes.push(boxBody);
            boxMeshes.push(boxMesh);

            var x = -distance;
            var y = height;
            var z = distance;

            var boxBody = new CANNON.Body({ mass: 10000 });
            boxBody.addShape(boxShape);
            var boxMesh = new THREE.Mesh(boxGeometry, material);
            world.add(boxBody);
            scene.add(boxMesh);
            boxBody.position.set(x, y, z);
            boxMesh.position.set(x, y, z);
            boxMesh.castShadow = true;
            boxMesh.receiveShadow = true;
            boxes.push(boxBody);
            boxMeshes.push(boxMesh);

            var x = -distance;
            var y = height;
            var z = -distance;

            var boxBody = new CANNON.Body({ mass: 10000 });
            boxBody.addShape(boxShape);
            var boxMesh = new THREE.Mesh(boxGeometry, material);
            world.add(boxBody);
            scene.add(boxMesh);
            boxBody.position.set(x, y, z);
            boxMesh.position.set(x, y, z);
            boxMesh.castShadow = true;
            boxMesh.receiveShadow = true;
            boxes.push(boxBody);
            boxMeshes.push(boxMesh);

            var x = 0;
            var y = height;
            var z = -distance;

            var boxBody = new CANNON.Body({ mass: 10000 });
            boxBody.addShape(boxShape);
            var boxMesh = new THREE.Mesh(boxGeometry, material);
            world.add(boxBody);
            scene.add(boxMesh);
            boxBody.position.set(x, y, z);
            boxMesh.position.set(x, y, z);
            boxMesh.castShadow = true;
            boxMesh.receiveShadow = true;
            boxes.push(boxBody);
            boxMeshes.push(boxMesh);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        var dt = 1 / 60;
        //var removeBody = [];
        //var removeMesh = [];

        var removeIndex = [];

        var addBody = [];
        var addMesh = [];

        function animate() {
            requestAnimationFrame(animate);
            if (controls.enabled) {
                while (removeIndex.length > 0) {
                //while (removeBody.length > 0) {
                    //console.log(removeBody.length);
                    //var tempBody = removeBody.pop();
                    //var tempMesh = removeMesh.pop();

                    //var tempBodyIndex = balls.indexOf(tempBody);
                    //console.log(tempBodyIndex); 
                    //var tempMeshIndex = ballMeshes.indexOf(tempMesh);
                    //console.log(tempMeshIndex);

                    //console.log("Index: " + tempBodyIndex + " " + tempMeshIndex);

                    //console.log("Prev Length: " + balls.length + " " + ballMeshes.length);

                    /*
                    world.remove(tempBody);
                    scene.remove(tempMesh);
                    */

                    var tempIndex = removeIndex.pop();
                    //var tempMeshIndex = removeMesh.pop();

                    world.remove(balls[tempIndex]);
                    scene.remove(ballMeshes[tempIndex]);

                    balls.splice(tempIndex, 1);
                    ballMeshes.splice(tempIndex, 1);

                    //console.log("Curr Length: " + balls.length + " " + ballMeshes.length);

                    //console.log("remove " + tempBody.id);

                    /*
                    console.log("Array start");
                    //console.log(ballBody.id);
                    for (var i = 0; i < balls.length; i++) {
                        console.log(balls[i]);
                    }
                    console.log("Array end");
                    */
                }


                while (addBody.length > 0) {
                    var tempBody = addBody.pop();
                    var tempMesh = addMesh.pop();


                    world.add(tempBody);
                    scene.add(tempMesh);

                    balls.push(tempBody);
                    ballMeshes.push(tempMesh);
                }

                world.step(dt);

                // Update ball positions
                for (var i = 0; i < balls.length; i++) {
                    ballMeshes[i].position.copy(balls[i].position);
                    ballMeshes[i].quaternion.copy(balls[i].quaternion);
                }

                // Update box positions
                for (var i = 0; i < boxes.length; i++) {
                    boxMeshes[i].position.copy(boxes[i].position);
                    boxMeshes[i].quaternion.copy(boxes[i].quaternion);
                }

                // rotate next planet
                nextPlanet.rotation.y += 0.02;
            }
            controls.update(Date.now() - time);
            renderer.render(scene, camera);
            time = Date.now();
        }

        var shootDirection = new THREE.Vector3();
        var shootVelo = 15;
        var projector = new THREE.Projector();
        function getShootDir(targetVec) {
            var vector = targetVec;
            targetVec.set(0, 0, 1);
            projector.unprojectVector(vector, camera);
            var ray = new THREE.Ray(sphereBody.position, vector.sub(sphereBody.position).normalize());
            targetVec.copy(ray.direction);
        }

        window.addEventListener("click", function (e) {
            if (controls.enabled == true) {
                var length = planetSizes.length;

                var x = sphereBody.position.x;
                var y = sphereBody.position.y;
                var z = sphereBody.position.z;

                var ballBody = new CANNON.Body({ mass: 1 });
                var ballShape = new CANNON.Sphere(planetSizes[cnt % length]);
                ballBody.addShape(ballShape);
                var ballGeometry = new THREE.SphereGeometry(ballShape.radius, 32, 32);
                var ballMesh = new THREE.Mesh(ballGeometry, materials[cnt % length]);
                world.add(ballBody);
                scene.add(ballMesh);

                ballMesh.castShadow = true;
                ballMesh.receiveShadow = true;
                balls.push(ballBody);
                ballMeshes.push(ballMesh);
                getShootDir(shootDirection);
                ballBody.velocity.set(shootDirection.x * shootVelo,
                    shootDirection.y * shootVelo,
                    shootDirection.z * shootVelo);

                // Move the ball outside the player sphere
                x += shootDirection.x * (sphereShape.radius * 1.02 + ballShape.radius);
                y += shootDirection.y * (sphereShape.radius * 1.02 + ballShape.radius);
                z += shootDirection.z * (sphereShape.radius * 1.02 + ballShape.radius);
                ballBody.position.set(x, y, z);
                ballMesh.position.set(x, y, z);

                var collided = false;
                /*
                console.log("Array start"); 
                //console.log(ballBody.id);
                for (var i = 0; i < balls.length; i++) {
                    console.log(balls[i]);        
                }
                console.log("Array end");  
                //console.log(balls);
                //console.log(balls.length);
                //console.log(ballMeshes);
                */

                ballBody.addEventListener("collide", function (e) {
                    if (e.body.shapes[0].radius != null) {
                        //console.log(ballBody);
                        if (ballBody.shapes[0].radius == e.body.shapes[0].radius) {
                            //removeBody.push(e.target);
                            //var meshid;
                            for (var i = 0; i < balls.length; i++) {
                                if (balls[i].id == e.target.id) {
                                    removeIndex.push(i);
                                    //meshid = i;
                                }
                            }

                            //removeMesh.push(ballMeshes[meshid]);
                            
                            

                            //console.log(e.target.id);
                            //console.log("Collide!");
                            //console.log(ballMeshes);


/*

                            // create a new ball
                            var length = planetSizes.length;

                            var x = e.target.position.x;
                            var y = e.target.position.y;
                            var z = e.target.position.z;

                            var newBallBody = new CANNON.Body({ mass: 1 });
                            var newBallShape = new CANNON.Sphere(planetSizes[10]);
                            newBallBody.addShape(newBallShape);
                            var newBallGeometry = new THREE.SphereGeometry(newBallShape.radius, 32, 32);
                            var newBallMesh = new THREE.Mesh(newBallGeometry, materials[10]);

                            // here?
                            newBallMesh.castShadow = true;
                            newBallMesh.receiveShadow = true;

                            newBallBody.velocity.set(0,
                                0,
                                0);

                            newBallBody.position.set(x, y, z);
                            newBallMesh.position.set(x, y, z);

                            addBody.push(newBallBody);
                            addMesh.push(newBallMesh);*/
                        }
                    }
                });
            }
            //cnt++;
            cnt = Math.floor(Math.random() * 3);
            // cnt == 1;

            scene.remove(nextPlanet);
            nextPlanet = new THREE.Mesh(new THREE.SphereGeometry(planetSizes[cnt % planetSizes.length], 32, 32), materials[cnt % planetSizes.length]);
            scene.add(nextPlanet);
            nextPlanet.position.set(0, 50, -20);
        });


    </script><canvas width="1848" height="1428" style="width: 924px; height: 714px;"></canvas>


</body>

</html>